{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport axios from 'axios';\nimport { connect } from 'react-redux';\nimport { createAction, handleActions } from 'redux-actions';\nimport querystring from 'query-string';\nimport { omit, get, wrap } from 'lodash';\nexport var actions = {\n  config: createAction('REACT_REDUX_OAUTH2/CONFIG'),\n  error: createAction('REACT_REDUX_OAUTH2/ERROR'),\n  start: createAction('REACT_REDUX_OAUTH2/START'),\n  reset: createAction('REACT_REDUX_OAUTH2/RESET'),\n  cancel: createAction('REACT_REDUX_OAUTH2/CANCEL'),\n  save: createAction('REACT_REDUX_OAUTH2/SAVE'),\n  signin: function signin(creds) {\n    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (f) {\n      return f;\n    };\n    return function (dispatch, getState) {\n      var config = getState().oauth.config;\n      dispatch(actions.start());\n      return new Promise(function (resolve, reject) {\n        axios.post('' + config.url + config.token, Object.assign({\n          client_id: config.client_id,\n          client_secret: config.client_secret,\n          grant_type: 'password',\n          scope: 'all'\n        }, creds)).then(function (res) {\n          dispatch(actions.sync(res.data, cb));\n          resolve(res);\n        }).catch(function (e) {\n          dispatch(actions.error(e));\n          reject(e);\n        });\n      });\n    };\n  },\n  signout: function signout() {\n    var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (f) {\n      return f;\n    };\n    return function (dispatch, getState) {\n      var _getState$oauth = getState().oauth,\n          user = _getState$oauth.user,\n          config = _getState$oauth.config;\n      return axios.delete('' + config.url + config.token, {\n        headers: {\n          'Authorization': 'Bearer ' + user.token.access_token\n        }\n      }).then(function (res) {\n        dispatch(actions.reset());\n        cb(null, res);\n      }).catch(function (e) {\n        dispatch(actions.error(e));\n        cb(e);\n      });\n    };\n  },\n  sync: function sync(token) {\n    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (f) {\n      return f;\n    };\n    return function (dispatch, getState) {\n      var config = getState().oauth.config;\n      return axios.get('' + config.url + config.token, {\n        headers: {\n          'Authorization': 'Bearer ' + token.access_token\n        }\n      }).then(function (res) {\n        var user = {\n          token: token,\n          profile: res.data\n        };\n        dispatch(actions.save(user));\n        cb(null, user);\n      }).catch(cb);\n    };\n  }\n};\nexport var reducer = handleActions({\n  'REACT_REDUX_OAUTH2/CONFIG': function REACT_REDUX_OAUTH2CONFIG(state, action) {\n    return _extends({}, state, {\n      config: action.payload\n    });\n  },\n  'REACT_REDUX_OAUTH2/START': function REACT_REDUX_OAUTH2START(state, action) {\n    return _extends({}, state, {\n      authenticating: true\n    });\n  },\n  'REACT_REDUX_OAUTH2/CANCEL': function REACT_REDUX_OAUTH2CANCEL(state, action) {\n    return _extends({}, state, {\n      authenticating: false\n    });\n  },\n  'REACT_REDUX_OAUTH2/ERROR': function REACT_REDUX_OAUTH2ERROR(state, action) {\n    return _extends({}, state, {\n      authenticating: false,\n      error: action.payload\n    });\n  },\n  'REACT_REDUX_OAUTH2/RESET': function REACT_REDUX_OAUTH2RESET(state, action) {\n    return _extends({}, state, {\n      authenticating: false,\n      error: null,\n      user: {\n        token: null,\n        profile: null\n      }\n    });\n  },\n  'REACT_REDUX_OAUTH2/SAVE': function REACT_REDUX_OAUTH2SAVE(state, action) {\n    return _extends({}, state, {\n      authenticating: false,\n      user: action.payload\n    });\n  }\n}, {\n  authenticating: false,\n  user: {\n    token: null,\n    profile: null\n  },\n  config: {\n    url: 'http://localhost',\n    token: '/oauth/token',\n    client_id: null,\n    client_secret: null,\n    providers: {\n      github: '/auth/github'\n    }\n  },\n  error: null\n});\nexport function signout(settings) {\n  settings = Object.assign({\n    success: function success() {},\n    failed: function failed() {}\n  }, settings);\n  return function (Component) {\n    return connect(function (state) {\n      return {\n        oauth: state.oauth\n      };\n    })(function (_React$Component) {\n      _inherits(_class, _React$Component);\n\n      function _class() {\n        _classCallCheck(this, _class);\n\n        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n      }\n\n      _class.prototype.handleClick = function handleClick() {\n        this.props.dispatch(actions.signout(function (e, res) {\n          return e ? settings.failed(e) : settings.success(null, res);\n        }));\n      };\n\n      _class.prototype.render = function render() {\n        var _this2 = this;\n\n        var _props = this.props,\n            oauth = _props.oauth,\n            rest = _objectWithoutProperties(_props, ['oauth']);\n\n        var props = Object.assign({}, omit(rest, ['dispatch']));\n        props.disabled = false;\n        props.disabled = oauth.authenticating || get(oauth, 'user.profile') === null;\n        props.onClick = wrap(props.onClick, function (func, e) {\n          _this2.handleClick(e);\n\n          return func(e);\n        });\n        return React.createElement(Component, props);\n      };\n\n      _createClass(_class, null, [{\n        key: 'defaultProps',\n        get: function get() {\n          return {\n            onClick: function onClick() {}\n          };\n        }\n      }]);\n\n      return _class;\n    }(React.Component));\n  };\n}\nexport function signin(settings) {\n  settings = Object.assign({\n    popup: {\n      scrollbars: 'no',\n      toolbar: 'no',\n      location: 'no',\n      titlebar: 'no',\n      directories: 'no',\n      status: 'no',\n      menubar: 'no',\n      top: '100',\n      left: '100',\n      width: '600',\n      height: '500'\n    },\n    listen: null,\n    success: function success() {},\n    cancel: function cancel() {},\n    failed: function failed() {}\n  }, settings);\n  return function (Component) {\n    return connect(function (state) {\n      return {\n        oauth: state.oauth\n      };\n    })(function (_React$Component2) {\n      _inherits(_class2, _React$Component2);\n\n      function _class2() {\n        _classCallCheck(this, _class2);\n\n        return _possibleConstructorReturn(this, _React$Component2.apply(this, arguments));\n      }\n\n      _class2.prototype.handleClick = function handleClick(e, provider) {\n        var _props2 = this.props,\n            dispatch = _props2.dispatch,\n            config = _props2.oauth.config,\n            state = _props2.state;\n        var query = state ? '?state=' + state : '';\n        var url = '' + config.url + config.providers[provider] + query;\n        var name = 'connecting to ' + provider;\n        dispatch(actions.start());\n        this.listenPopup(window.open(url, name, querystring.stringify(settings.popup).replace(/&/g, ',')));\n      };\n\n      _class2.prototype.listenPopup = function listenPopup(popup) {\n        var _this4 = this;\n\n        var dispatch = this.props.dispatch;\n\n        if (popup.closed) {\n          dispatch(actions.cancel());\n          settings.cancel();\n        } else {\n          var listen = function listen() {\n            var token = void 0;\n\n            try {\n              token = querystring.parse(popup.location.search.substr(1));\n            } catch (e) {}\n\n            if (token && token.access_token) {\n              dispatch(actions.sync(token, function (err, user) {\n                if (err) {\n                  dispatch(actions.error(err));\n                  settings.failed(err);\n                  popup.close();\n                } else {\n                  settings.success(user);\n                }\n              }));\n              popup.close();\n            } else {\n              setTimeout(_this4.listenPopup.bind(_this4, popup), 0);\n            }\n          };\n\n          settings.listen ? settings.listen.call(this, popup, settings) : listen();\n        }\n      };\n\n      _class2.prototype.render = function render() {\n        var _this5 = this;\n\n        var _props3 = this.props,\n            oauth = _props3.oauth,\n            provider = _props3.provider,\n            rest = _objectWithoutProperties(_props3, ['oauth', 'provider']);\n\n        var props = Object.assign({}, omit(rest, ['dispatch', 'onCancel', 'onSuccess', 'onFailed']));\n        props.disabled = oauth.authenticating || get(oauth, 'user.profile') !== null;\n        props.onClick = wrap(props.onClick, function (func, e) {\n          _this5.handleClick(e, provider);\n\n          return func(e);\n        });\n        return React.createElement(Component, _extends({}, props, {\n          provider: provider\n        }));\n      };\n\n      _createClass(_class2, null, [{\n        key: 'defaultProps',\n        get: function get() {\n          return {\n            onClick: function onClick() {}\n          };\n        }\n      }]);\n\n      return _class2;\n    }(React.Component));\n  };\n}","map":null,"metadata":{},"sourceType":"module"}